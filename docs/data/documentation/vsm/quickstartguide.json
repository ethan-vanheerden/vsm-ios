{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Index","level":2,"type":"heading","text":"Index"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/VSM\/documentation\/VSM\/QuickstartGuide#Getting-Started"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#1-define-your-states-and-models"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#2-define-your-view"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#3-render-the-current-state"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#4-add-behaviors-to-your-view"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#5-using-your-view"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/VSM\/documentation\/VSM\/QuickstartGuide#Additional-Learning"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#improving-testability"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#breaking-state-cycles-with-builders"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"#options-for-controlling-state-flow"}]}]}]},{"anchor":"Getting-Started","level":2,"type":"heading","text":"Getting Started"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the following steps, we will walk through building a feature that loads a blog post from an API. Once loaded, the user will see the blog text and a delete button. The delete button will send a “delete” message to the API and then show a completion screen."}]},{"anchor":"Bleep-bloop","level":3,"type":"heading","text":"Bleep bloop"},{"anchor":"1-Define-your-States-and-Models","level":3,"type":"heading","text":"1. Define your States and Models"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once you have read and internalized the feature requirements, you will convert these requirements into a “State Journey” which will be defined in a series of swift types (usually enums and structs)."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, we’ll start by declaring the State\/ViewState enum which defines every State that your View can be in, along with the protocols that contain the Data and Actions that the user will be able to see and do in each State."}]},{"type":"codeListing","syntax":"swift","code":["enum BlogViewState {","    case initialized(BlogLoaderModeling)","    case loading","    case loaded(LoadedBlogModeling)","    case deleted","}","","protocol BlogLoaderModeling {","    func loadBlog() -> AnyPublisher<BlogViewState, Never>","}","","protocol LoadedBlogModeling {","    var blogText: String { get }","    func delete() -> AnyPublisher<BlogViewState, Never>","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You’ll notice that each of the Actions above "},{"type":"emphasis","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"returns a new State"}]}]},{"type":"text","text":" (or a future State publisher). This is the essence of the VSM design pattern. Every Action should emit a new State to update the View, and move the user along the “State Journey”."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we will define the concrete behavior for each of these Models."}]},{"type":"codeListing","syntax":"swift","code":["struct BlogLoaderModel: BlogLoaderModeling {","    let blogId: Int","","    func loadBlog() -> AnyPublisher<BlogViewState, Never> {","        \/\/ Builds a publisher that immediately sets the State to `.loading`","        let statePublisher = CurrentValueSubject<BlogViewState, Never>(.loading)","        BlogAPI.getBlog(blogId) { blogText in","            \/\/ After the blog is loaded, the new `.loaded` State is emitted on the same publisher","            statePublisher.value = .loaded(LoadedBlogModel(blogId: blogId, blogText: blogText))","        }","        return statePublisher.eraseToAnyPublisher()","    }","}","","struct LoadedBlogModel: LoadedBlogModeling {","    let blogId: Int","    let blogText: String","","    func delete() -> AnyPublisher<BlogViewState, Never> {","        \/\/ Kicks off a fire-and-forget delete operation","        BlogAPI.queueBlogForDeletion(blogId)","        \/\/ Immediately returns the new `.deleted` State","        return Just(BlogViewState.deleted).eraseToAnyPublisher()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can add any number of supporting functions to a Model, as long as they are directly related to the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"single-purpose"}]},{"type":"text","text":" of the Model. (Such as converting API data to viewable format to support "},{"type":"codeVoice","code":"loadBlog()"},{"type":"text","text":".) These ancillary functions will be hidden from the View by the protocols associated with each State."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that the above Models omit some dependency injection. These examples are meant to convey only the basic structure of how States and Models correlate."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Detailed explanations can be found below this guide which cover complex topics such as using a “Builder” to offload the responsibility of constructing each State’s Model. In addition, examples of using Composed-Protocol Dependency Injection (CPDI) to satisfy your Model’s dependency needs can be found in the "},{"type":"reference","isActive":true,"identifier":"Demos\/Shopping"},{"type":"text","text":"."}]},{"anchor":"2-Define-your-View","level":3,"type":"heading","text":"2. Define your View"},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, build your SwiftUI "},{"type":"codeVoice","code":"View"},{"type":"text","text":" (or UIKit "},{"type":"codeVoice","code":"UIViewController"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"UIView"},{"type":"text","text":") and conform it to the "},{"type":"codeVoice","code":"ViewStateRendering"},{"type":"text","text":" protocol. This will require that you define a "},{"type":"codeVoice","code":"StateContainer"},{"type":"text","text":" property with your feature’s State\/ViewState type."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ SwiftUI","struct BlogView: View, ViewStateRendering {","    @StateObject var container: StateContainer<BlogViewState>","    ...","}"]},{"type":"codeListing","syntax":"swift","code":["\/\/ UIKit","class BlogViewController: UIViewController, ViewStateRendering {","    var container: StateContainer<BlogViewState>","    var cancellable: AnyCancellable?","","    init(state: BlogViewState) {","        container = .init(state: state)","        super.init(nibName: nil, bundle: nil)","        cancellable = container.$state.sink { [weak self] newState in self?.render(state: newState) }","    }","    ...","}"]},{"anchor":"3-Render-the-current-State","level":3,"type":"heading","text":"3. Render the current State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, you’ll want to add code that draws the State on screen when it updates\/loads."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ SwiftUI","...","var body: some View {","    VStack {","        switch container.state {","        case .loading, .initialized:","            ProgressView()","        case .loaded(let loadedBlogModel):","            Text(loadedBlogModel.blogText)","            Button(\"Delete\")","        case .deleted:","            Text(\"Deleted!\")","        }","    }","}","..."]},{"type":"codeListing","syntax":"swift","code":["\/\/ UIKit","...","func render(state: BlogViewState) {","    switch state {","    case .loading, .initialized:","        showLoadingState()","    case .loaded(let loadedBlogModel):","        hideLoadingState()","        blogTextView.text = loadedBlogModel.blogText","    case .deleted:","        showDeletedState()","    }","}","..."]},{"anchor":"4-Add-behaviors-to-your-View","level":3,"type":"heading","text":"4. Add behaviors to your View"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now that your View is drawing each State, you’ll want to add behaviors to your View."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To do this, you call the Action functions found on each State. "},{"type":"strong","inlineContent":[{"type":"text","text":"Be sure to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"OBSERVE"}]},{"type":"text","text":" each Action using "},{"type":"codeVoice","code":"container.observe(...)"},{"type":"text","text":" or the State progression will fail."}]},{"type":"text","text":" (Don’t worry, the compiler will warn you if you forget.)"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ SwiftUI","...","var body: some View {","    VStack {","        switch container.state {","        case .loading, .initialized:","            ...","        case .loaded(let loadedBlogModel):","            ...","            Button(\"Delete\") {","                container.observe(loadedBlogModel.delete())","            }","        case .deleted:","            ...","        }","    }.onAppear {","        if case .initialized(let blogLoaderModel) = container.state {","            container.observe(blogLoaderModel.loadBlog())","        }","    }","}","..."]},{"type":"codeListing","syntax":"swift","code":["\/\/ UIKit","...","override func viewDidLoad() {","    super.viewDidLoad()","    if case .initialized(let blogLoaderModel) = container.state {","        container.observe(blogLoaderModel.loadBlog())","    }","}","...","func render(state: BlogViewState) {","    switch state {","    case .loading, .initialized:","        ...","    case .loaded(let loadedBlogModel):","        ...","        deleteButton.addAction(UIAction(handler: { _ in","            container.observe(loadedBlogModel.delete())","        }), for: .touchUpInside)","    case .deleted:","        ...","    }","}","..."]},{"anchor":"5-Using-your-View","level":3,"type":"heading","text":"5. Using your View"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we are ready to use the Blog feature that we built using the VSM pattern. Here is one example of how to instantiate a "},{"type":"codeVoice","code":"ViewStateRendering"},{"type":"text","text":" view:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ SwiftUI","BlogView(stateContainer: .init(state: .initialized(BlogLoaderModel(blogId: 1))))"]},{"type":"codeListing","syntax":"swift","code":["\/\/ UIKit","BlogViewController(state: .initialized(BlogLoaderModel(blogId: 1)))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Initialization of a "},{"type":"codeVoice","code":"ViewStateRendering"},{"type":"text","text":" view is very flexible. You can customize how it is instantiated and what parameters are required. A good example is to add a convenience initializer that accepts the dependencies and other parameters without expecting outside callers to know about the internal States of the "},{"type":"codeVoice","code":"ViewStateRendering"},{"type":"text","text":" view. For example:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ SwiftUI","struct BlogView: View, ViewStateRendering {","    ...","    init(urlSession: UrlSession, blogId: Int) {","        _container = .init(state: .initialized(BlogLoaderModel(urlSession: urlSession, blogId: blogId)))","        \/\/ Optional: You can call blogLoaderModel.loadBlog() here if you don't want to wait for onAppear","    }","    ...","}","","\/\/ Resulting in the following initialization code:","BlogView(urlSession: .shared, blogId: 1)"]},{"type":"codeListing","syntax":"swift","code":["\/\/ UIKit","class BlogViewController: UIViewController, ViewStateRendering {","    ...","    init(urlSession: UrlSession, blogId: Int) {","        container = .init(state: .initialized(BlogLoaderModel(urlSession: urlSession, blogId: blogId)))","        \/\/ Optional: You can call blogLoaderModel.loadBlog() here if you don't want to wait for viewDidLoad","        ...","    }","    ...","}","","\/\/ Resulting in the following initialization code:","BlogViewController(urlSession: .shared, blogId: 1)"]},{"anchor":"Additional-Learning","level":2,"type":"heading","text":"Additional Learning"},{"anchor":"Improving-Testability","level":3,"type":"heading","text":"Improving Testability"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To improve the testability of your Models, you shouldn’t instantiate other concrete Model types directly within your Model. Instead, you should require that Model builders be injected into each Model."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This will allow a unit test to focus on a single Model type by mocking the construction of other Models. Doing so eliminates the possibility of accidentally invoking any other Model types or encountering other side effects in your tests."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following is an example of a simple function being used to abstract the construction of the next State’s Model:"}]},{"type":"codeListing","syntax":"swift","code":["struct BlogLoaderModel: BlogLoaderModeling {","    let blogId: Int","    let loadedBlogModelBuilder: (Int, String) -> LoadedBlogModeling","","    func loadBlog() -> AnyPublisher<BlogViewState, Never> {","        let statePublisher = CurrentValueSubject<BlogViewState, Never>(.loading)","        BlogAPI.getBlog(blogId) { blogText in","            statePublisher.value = .loaded(loadedBlogModelBuilder(blogId, blogText))","        }","        return statePublisher.eraseToAnyPublisher()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, the code that constructs the next State’s Model is encapsulated by the builder function. This allows you to inject mocks for the next State’s Model for unit testing each Action in isolation, like so:"}]},{"type":"codeListing","syntax":"swift","code":["let mockLoadedBlogModel = MockLoadedBlogModel(...)","let subject = BlogLoaderModel(..., loadedBlogModelBuilder: { _ in return mockLoadedBlogModel })","let output: [BlogViewState] = try awaitPublisher(subject.loadBlog())","if let newState = output.first, case .loaded(let model) = newState { \/*no-op*\/ } else {","    XCTFail(\"loadBlog Action failed to produce the correct state.\")","}"]},{"anchor":"Breaking-State-Cycles-with-Builders","level":3,"type":"heading","text":"Breaking State Cycles with Builders"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some “State Journeys” can be cyclical, which can cause problems when trying to make Models mockable and unit-testable (see "},{"overridingTitleInlineContent":[{"type":"text","text":"above"}],"isActive":true,"type":"reference","identifier":"#improving-testability","overridingTitle":"above"},{"type":"text","text":"). For example, if we added a “reload” Action to the blog feature on the "},{"type":"codeVoice","code":".loaded"},{"type":"text","text":" State, the "},{"type":"codeVoice","code":"LoadedBlogModel"},{"type":"text","text":" would require a builder for "},{"type":"codeVoice","code":"BlogLoaderModel"},{"type":"text","text":" and vice-versa. Like so:"}]},{"type":"codeListing","syntax":"swift","code":["struct BlogLoaderModel {","    ...","    let loadedBlogModelBuilder: (Int, String) -> LoadedBlogModeling","","    func loadBlog() -> AnyPublisher<BlogViewState, Never> {","        ...","        statePublisher.value = .loaded(loadedBlogModelBuilder(blogId, blogText))","        ...","    }","}","","struct LoadedBlogModel {","    ...","    let blogLoaderModelBuilder: (Int) -> BlogLoaderModeling","","    func reload() -> AnyPublisher<BlogViewState, Never> {","        return blogLoaderModelBuilder(blogId).loadBlog()","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But how would you instantiate "},{"type":"codeVoice","code":"BlogLoaderModel"},{"type":"text","text":" if both Models require instructions on how to build each other?"}]},{"type":"codeListing","syntax":"swift","code":["let blogLoaderModel = BlogLoaderModel(..., loadedBlogModelBuilder: {","    LoadedBlogModel(..., blogLoaderModelBuilder: {","        BlogLoaderModel(..., loadedBlogModelBuilder: {","            \/\/ and so on, forever...","        })","    })","})","","BlogView(container: .init(state: .initialized(blogLoaderModel)))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As you can see, the Model constructors are unresolvable if the States can loop."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In order to break the cycle, a tie-breaker is needed. A single “Model Builder” type can be injected into each Model to offload the process of building other Models. For example:"}]},{"type":"codeListing","syntax":"swift","code":["protocol BlogModelBuilding {","    func buildBlogLoaderModel(blogId: Int) -> BlogLoaderModeling","    func buildLoadedBlogModel(blogId: Int, blogText: String) -> LoadedBlogModeling","}","","class BlogModelBuilder: BlogModelBuilding {","    func buildBlogLoaderModel(blogId: Int) -> BlogLoaderModeling {","        return BlogLoaderModel(blogId: blogId, modelBuilder: self)","    }","","    func buildLoadedBlogModel(blogId: Int, blogText: String) -> LoadedBlogModeling {","        return LoadedBlogModel(blogId: blogId, blogText: blogText, modelBuilder: self)","    }","}","","struct BlogLoaderModel: BlogLoaderModeling {","    ...","    let modelBuilder: BlogModelBuilding","    ...","    func loadBlog() -> AnyPublisher<BlogViewState, Never> {","        ...","        statePublisher.value = .loaded(modelBuilder.buildBlogLoaderModel(blogId: blogId, blogText: blogText))","        ...","    }","}","","struct LoadedBlogModel: LoadedBlogModeling {","    ...","    let modelBuilder: BlogModelBuilding","    ...","    func reload() -> AnyPublisher<BlogViewState, Never> {","        return modelBuilder.buildBlogLoaderModel(blogId: blogId).loadBlog()","    }","}","...","let blogLoaderModel = BlogLoaderModel(..., modelBuilder: BlogModelBuilder())","","BlogView(container: .init(state: .initialized(blogLoaderModel)))"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now, the code that constructs each Model is encapsulated within the Builder. This allows you to inject mocks for each Model to unit test each Action in isolation, like so:"}]},{"type":"codeListing","syntax":"swift","code":["let mockBlogLoaderModel = MockBlogLoaderModel(loadBlogImpl: {","    return Just(BlogViewState.loading).eraseToAnyPublisher()","})","let mockBuilder = MockBlogModelBuilder(buildBlogLoaderModelImpl: { _ in","    return mockBlogLoaderModel","})","let subject = LoadedBlogModel(..., modelBuilder: mockModelBuilder)","let output: [BlogViewState] = try awaitPublisher(subject.reload())","XCTAssertEqual(output.first, BlogViewState.loading, \"reload Action failed to produce the correct state.\")"]},{"anchor":"Options-for-Controlling-State-Flow","level":3,"type":"heading","text":"Options for Controlling State Flow"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sometimes you don’t need the full power (and overhead) of Combine "},{"type":"codeVoice","code":"Publisher"},{"type":"text","text":"s to manage the flow of State in your feature. There are two other options you can use to manage how an Action leads to a new State:"}]},{"anchor":"AsyncAwait","level":4,"type":"heading","text":"Async\/Await"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can utilize Swift’s async\/await behavior to progress from one State to another by conforming your Action to the async\/await requirements, like so:"}]},{"type":"codeListing","syntax":"swift","code":["func delete() async -> BlogViewState {","    await BlogAPI.deleteBlog(blogId)","    return .deleted","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The main limitation of using async\/await is that you can only emit one new State from the Action. Here’s how you would observe that function call from the View:"}]},{"type":"codeListing","syntax":"swift","code":["container.observe({ await loadedBlogModel.delete() })"]},{"anchor":"Synchronous-State-Progression","level":4,"type":"heading","text":"Synchronous State Progression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you are "},{"type":"emphasis","inlineContent":[{"type":"text","text":"synchronously"}]},{"type":"text","text":" moving from one State to another you can simply return a new State from any Action, like so:"}]},{"type":"codeListing","syntax":"swift","code":["func delete() -> BlogViewState {","    BlogAPI.queueBlogForDeletion(blogId)","    return .deleted","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The two limitations of this approach are that you can only emit one State and it must be returned immediately. Here’s how you would observe that function call from the View:"}]},{"type":"codeListing","syntax":"swift","code":["container.observe(loadedBlogModel.delete())"]},{"anchor":"No-State-Progression","level":4,"type":"heading","text":"No State Progression"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In some scenarios, an Action may not need to emit a new State for the current View. Instead, these Actions kick off some external, ancillary, or silent process. For these cases, your Model’s Action can return "},{"type":"codeVoice","code":"Void"},{"type":"text","text":". For example:"}]},{"type":"codeListing","syntax":"swift","code":["func autoSaveBlogChanges(_ blogText: String) {","    BlogCache.autoSave(blogText)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"No observation of the Action is necessary in the view because it does not emit a new State:"}]},{"type":"codeListing","syntax":"swift","code":["@State editedText = \"\"","","var body: some View {","    TextField(\"Blog Text\", text: $blogText)","        .onChange(of: blogText) { newValue in","            loadedBlogModel.autoSaveBlogChanges(newValue)","        }","}"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/vsm\/quickstartguide"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/VSM\/documentation\/VSM\/QuickstartGuide","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"This guide jumps directly into the VSM code by helping the reader apply VSM concepts to build a simple feature"}],"kind":"article","metadata":{"roleHeading":"Article","title":"QuickStart Guide","role":"article","modules":[{"name":"VSM"}]},"hierarchy":{"paths":[["doc:\/\/VSM\/documentation\/VSM"]]},"references":{"#2-define-your-view":{"title":"Define your View","titleInlineContent":[{"type":"text","text":"Define your View"}],"type":"link","identifier":"#2-define-your-view","url":"#2-define-your-view"},"#4-add-behaviors-to-your-view":{"title":"Add behaviors to your View","titleInlineContent":[{"type":"text","text":"Add behaviors to your View"}],"type":"link","identifier":"#4-add-behaviors-to-your-view","url":"#4-add-behaviors-to-your-view"},"Demos/Shopping":{"title":"Demo App","titleInlineContent":[{"type":"text","text":"Demo App"}],"type":"link","identifier":"Demos\/Shopping","url":"Demos\/Shopping"},"#3-render-the-current-state":{"title":"Render the current State","titleInlineContent":[{"type":"text","text":"Render the current State"}],"type":"link","identifier":"#3-render-the-current-state","url":"#3-render-the-current-state"},"#improving-testability":{"title":"Improving Testability","titleInlineContent":[{"type":"text","text":"Improving Testability"}],"type":"link","identifier":"#improving-testability","url":"#improving-testability"},"#breaking-state-cycles-with-builders":{"title":"Breaking State Cycles with Builders","titleInlineContent":[{"type":"text","text":"Breaking State Cycles with Builders"}],"type":"link","identifier":"#breaking-state-cycles-with-builders","url":"#breaking-state-cycles-with-builders"},"doc://VSM/documentation/VSM/QuickstartGuide#Getting-Started":{"abstract":[],"title":"Getting Started","kind":"section","type":"topic","identifier":"doc:\/\/VSM\/documentation\/VSM\/QuickstartGuide#Getting-Started","url":"\/documentation\/vsm\/quickstartguide#Getting-Started"},"doc://VSM/documentation/VSM":{"role":"collection","title":"VSM","abstract":[{"type":"text","text":"An iOS framework for the VSM Architecture"}],"identifier":"doc:\/\/VSM\/documentation\/VSM","kind":"symbol","type":"topic","url":"\/documentation\/vsm"},"#1-define-your-states-and-models":{"title":"Define your States and Models","titleInlineContent":[{"type":"text","text":"Define your States and Models"}],"type":"link","identifier":"#1-define-your-states-and-models","url":"#1-define-your-states-and-models"},"doc://VSM/documentation/VSM/QuickstartGuide#Additional-Learning":{"abstract":[],"title":"Additional Learning","kind":"section","type":"topic","identifier":"doc:\/\/VSM\/documentation\/VSM\/QuickstartGuide#Additional-Learning","url":"\/documentation\/vsm\/quickstartguide#Additional-Learning"},"#5-using-your-view":{"title":"Using your View","titleInlineContent":[{"type":"text","text":"Using your View"}],"type":"link","identifier":"#5-using-your-view","url":"#5-using-your-view"},"#options-for-controlling-state-flow":{"title":"Options for Controlling State Flow","titleInlineContent":[{"type":"text","text":"Options for Controlling State Flow"}],"type":"link","identifier":"#options-for-controlling-state-flow","url":"#options-for-controlling-state-flow"}}}